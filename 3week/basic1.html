<html>
    <title>2022 하계방학 프로그래밍기초 3주차 과제</title>
    <head>2020975050 소프트웨어학과 이지홍</head>
    <body>
        <h1>GO 언어</h1>
        <p>GO언어는 2009년 11월에 구글에서 발표된 후 2012년 3월에 정식 발표된 프로그래밍 언어입니다. GO 언어의 특징으로는 컴파일 언어이지만 컴파일러의 컴파일 속도가 매우 빨라서 인터프리터 언어처럼 쓸 수 있습니다.<br>
            자료형 체계는 정적 타입으로 이루어져있어 파이썬과 같은 언어에 익숙한 사람은 사용에 불편할 수 있습니다. 정적타입이란 자료형을 컴파일 시에 결정하는 언어들을 말합니다. 파이썬은 실행 시 자료형을 결정하는 동적타입에 속합니다.<br>
            또한, GoRoutine이라고 불리는 비동기 메커니즘을 제공합니다. 때문에 이벤트 처리나 병렬 프로그래밍 등이 간단해집니다. 단, 이를 프로그래머가 동기화 문제를 처리해야하며, 동기화를 무시할 경우 프로그램이 비정상 종료되는 경우가 생깁니다.<br>
            멀티스레딩 메커니즘이지만 자체적인 스케줄러에 의해 관리되는 경량 스레드이므로, CPU 코어수와 무관하게 수백, 수천개를 작성하여도 성능에 문제가 생기지 않습니다.<br>
            그리고 컴파일 언어이기 때문에 속도가 느린 스크립트 언어에서 연산 퍼포먼스가 필요한 부분을 GO 언어로 대체하여 넣을 수 있습니다.<br>
            하지만 바이트코드를 생성하는 언어가 아니기 때문에, 바이너리만 배포할 경우 해당 타깃 머신에 맞추어서 각각 컴파일 해주어야합니다. 거기에 더해 가비지 컬렉션이나 제네릭을 지원하지 않기 때문에, 고성능 연산이나 저수준 시스템 개발에서는 주로 사용되지 않고 개발 속도와 실행 속도, 병행성 사이의 적정 지점이 필요한 서버 애플리케이션 개발에서 사용되는 편입니다.<br>
            여기서 가비지 컬렉션이란, 유효하지 않은 메모리인 가비지를 알아서 정리해주는 기능입니다.</p>
        <h1>RUST 언어</h1>
        <p>RUST언어는 메모리 안정성과 성능 및 편의성에 중점을 둔 프로그래밍 언어입니다. 가비지 컬렉터 없이 메모리 안정성을 제공하는 대표적인 언어로 C++의 대체제로서 개발됐습니다.<br>
            C/C++과 동등한 수준의 속도를 유지하면서 안전성과 동시성을 향상시키는 것을 목표로 설계됐기 때문에, 안전한 코드에서는 메모리 관리 실수를 범하기 쉬운 일부 기능들의 사용을 제한합니다. 모든 변수는 RAII가 강제되며, 컴파일러는 모든 변수의 수명과 참조자의 유효성을 검증합니다.<br>
            RAII는 디자인 패턴 중 하나로, 클래스 소멸자가 호출될 때 자원 할당을 해제하는 작업입니다.<br>
            함수형 프로그래밍 언어이고, 객체 상속 대신 다른 언어에서의 인터페이스와 비슷한 트레이트라는 개념을 기반으로 다형성을 달성합니다. 타입이 강제되는 매크로를 사용해 언어의 확장이 가능하고, 현대적인 모듈 시스템을 이용해 쉽게 모듈화도 가능합니다.<br>
            안전한 메모리 관리를 위해 소유권과 수명이라는 개념을 이용하여 컴파일 단계에서 메모리 관리를 합니다. 소유권이란 객체의 생성과 소멸을 관리하기 위한 개념이고, 수명 파라메터는 컴파일러가 참조자의 유효성을 검증하기 위한 개념입니다.<br>
            거기에 모든 변수의 가변성을 컴파일 타임에 구분하므로 안전하게 관리가 가능합니다. 다른 특징으로는 예외 처리가 없다는 점인데, 에러가 처리해주어야 한다면 함수에서 에러를 처리할 것인지, 프로그램을 종료시킬 것인지 명시적으로 작성해야하는 함수를 반환합니다.<br>
            그리고 열거 값(enum)을 구조체나 튜플로 정의하여 내부에 값을 포함하는 것이 가능합니다. 이외에 하이지닉 매크로와 비동기 프로그래밍을 지원하는 점, 제네릭을 지원하는 등의 특징을 가지고 있습니다.</p>
        <h1>gdb</h1>
        <p>GNU Debugger로 불리는 GDB는 GNU 소프트웨어 시스템을 위한 기본 디버거입니다. 다양한 유닉스 기반의 시스템에서 동작하는 이식성 있는 디버거로, C, C++, Fortlan 등의 여러 프로그래밍 언어를 지원합니다.<br>
            GNU란 운영체제 중 하나이자 컴퓨터 소프트웨어의 모음집으로 현재 커널을 GNU 소프트웨어와 함께 사용하면서 LINUX를 결합하여 LINUX라고 불리는 경우가 많습니다.<br>
            GDB는 사용자가 프로그램의 내부 변수들의 값을 주시하거나 변경할 수 있게 해주고, 프로그램의 일반적인 실행 과정과 독립적으로 함수를 호출할 수도 있게 해줍니다.<br>
            또한 GDB는 GDB가 한 머신 상에서 동작하고, 디버그할 프로그램은 다른 머신 상에서 동작하게 끔 하는 원격 디버깅을 지원하고, 이는 TCP/IP나 원격지의 직렬 포트로 통신합니다.</p>
        <h1>fopen과 freopen</h1>
        <p>fopen과 freopen 함수는 둘 다 파일을 여는 행위는 같지만, freopen 함수는 스트림이 추가되어 있어, 지정한 스트림을 현재 열 파일의 스트림으로 변경시키는 역할을 수행합니다. 그렇기에 freopen으로 파일을 열게 되면 scanf, printf와 같은 함수들을 사용할 수 있다는 장점이 있습니다.<br>
            반대로, fopen 함수를 사용했을 경우에는 스트림 변경이 없기 때문에, fscanf, fprintf와 같은 함수들을 사용하여야 합니다. 다만 freopen을 이용하여 파일을 연 후 다시 표준 입출력으로 돌아갈려면 freopen의 파일명을 /dev/tty로 설정해 함수를 실행하거나, fdopen 함수를 이용해야하는 단점도 있습니다.<br></p>
        <h1>포인터(*)와 참조(&)의 차이</h1>
        <p>포인터는 메모리의 주소를 가질 수 있는 변수입니다. 참조는 참조자가 자신이 참조하는 변수를 대신할 수 있는 또 하나의 이름으로 변수 명을 통해서 메모리에 참조합니다.<br>
            포인터는 nullptr로 초기화가 가능하지만, 참조의 경우 선언과 동시에 초기화를 해주어야하는 특성때문에, nullptr를 가질 수 없을뿐더러 가리키는 대상을 변경할 수 없습니다.<br>
            또한, 포인터는 주소 값을 저장해야하기 때문에 별도의 메모리 공간을 소모하지만, 참조는 같은 메모리 공간을 사용하기 때문에 별도의 메모리 공간을 소모하지 않습니다.<br>
            다른 차이점으로는 매개 변수로써 함수 인자 전달 시 포인터는 값 복사가 일어나서 메모리를 더 소모하지만, 참조의 경우 값 복사가 일어나지 않기 때문에 메모리를 소모하지 않습니다.</p>
        <h1>함수 포인터와 람다 함수</h1>
        <h3>함수 포인터</h3>
        <p>함수 포인터는 이름 그대로 함수를 가리키는 포인터입니다. 함수 또한 text 섹션에 저장되어 주소가 있기 때문에 그 주소를 가리키는 포인터이고, 선언은 반환하는 데이터의 자료형, 함수 포인터의 이름, 매개변수로 이루어집니다. ex) int (*Name)(int a, int b)<br>
            함수 포인터는 함수를 또 다른 함수의 인수로 전달하는 상황 등에서 유용하게 사용됩니다. 함수 포인터의 단점으로는 복잡한 표기법인데 이는 typedef나 auto 키워드를 통해서 해결할 수 있습니다.</p>
        <h3>람다 함수</h3>
        <p>함수 포인터와 비슷하게 함수를 또 다른 함수의 인수로 전달하는 방법인 람다 함수가 있습니다. 람다 함수는 [캡처](매개변수){함수의 동작}(호출 시 인자) 형태로 이루어집니다. ex) [](int a, int b){cout << a + b << endl;}(10,20)<br>
            위 형식에서 소괄호로 이루어지는 부분은 생략이 가능합니다. 캡처의 경우 변수를 복사해서 사용하는 경우와 참조해서 사용하는 경우로 나뉩니다. 변수 이름만 대괄호에 넣을 경우 변수를 복사해서 사용하기 때문에 람다 함수 내부에서 해당 변수에 대입은 불가능합니다.<br>
            &를 사용해서 참조를 대괄호에 넣을 경우 참조해서 람다 함수 내부에서 사용하기 때문에 해당 변수에 대입이 가능합니다. 대괄호에 =만 넣는 경우 모든 외부 변수를 복사해서 사용한다는 의미이고, 대괄호에 &만 넣는 경우 모든 외부 변수를 참조해서 사용한다는 의미입니다.<br>
            이러한 람다 함수는 auto를 이용해서 특정 변수에 담아둔 후 함수의 인수로 전달하거나, 쉽게 가져다 쓸 수 있습니다.</p>
        <h1>콜백함수와 콜백지옥</h1>
        <p>콜백함수는 다른 함수의 인자로써 이용되는 함수나 어떤 이벤트에 의해 호출되어지는 함수를 의미합니다. 따라서 위에서 설명한 람다 함수와 함수 포인터를 인수를 전달하여 사용하면 그건 콜백함수라고 부를 수 있습니다.<br>
            하지만 이러한 콜백 함수를 여러 겹 중첩해서 사용하면 피라미드 형태로 코드의 들여쓰기가 심해지고 가독성이 안좋아지는 현상인 콜백지옥이 일어날 수 있습니다.</p>
        <h1>C++ auto 타입과 제네릭 타입</h1>
        <h3>auto 타입</h3>
        <p>auto 키워드는 선언된 변수의 초기화 식을 사용하여 해당 형식을 추론하도록 컴파일러에게 지시하는 키워드입니다. 이를 통해 변수 혹은 인스턴스의 형식이 자동으로 결정되는데 이를 타입추론이라고 부릅니다.<br>
            단, 변수를 초기화 할때만 작동하기 때문에 초기화값이 없으면 auto 기능은 타입추론을 할 수 없기때문에 사용 불가능합니다. 또한, 함수 매개 변수와 함께 사용할 수 없다는 점도 있습니다.<br>
            위에서 설명했듯이 함수포인터나 람다 함수처럼 유연하지 않은 함수 타입이나 벡터 등을 유연하게 사용할 수 있다는 장점이 있습니다.</p>
        <h3>제네릭 타입</h3>
        <p>제네릭은 클래스 내부에서 타입을 지정하는것이 아닌 외부에서 사용자에 의해 지정되는 것을 의미합니다. 외부에서 지정해주고 컴파일 과정에서 해당 타입으로 캐스팅되기 때문에 관리하기가 편하다는 장점이 있습니다.<br>
            이때 타입 파라미터로 int, double과 같은 원시타입은 올 수 없고 Integer, Double과 같은 참조 타입이 올 수 있습니다. 자바에서 제네릭을 통해 메소드, 클래스를 생성하는것도 가능합니다.<br>
            제네릭으로 받는 타입을 제한하는 것 또한 extends와 super 그리고 와일드카드인 ?로 가능합니다.</p>
        <h1>void 포인터와 malloc</h1>
        <p>void 포인터는 다른 자료형의 포인터들과 다르게 자료형에 상관없이 주소만을 바라보는 포인터입니다. 때문에 자료형을 자주 바꾸어서 써야하는 경우 void 포인터와 캐스팅을 통하여 편리하게 사용할 수 있습니다.<br>
            대표적으로 malloc함수의 경우 void 포인터가 반환값으로, 사용자가 int형으로 사용할지 string형태로 사용할지 모르기 때문에 void 포인터 형태로 반환하여 캐스팅을 통해 여러번 정의하지 않고 하나의 함수로 사용할 수 있게끔 합니다.</p>
        <h1>gcc의 컴파일 과정</h1>
        <p>gcc는 c언어용 컴파일러로 4단계의 컴파일 과정을 거칩니다. 먼저 .c, .cpp 등의 소스코드를 .i 파일로 변환하는 전처리기를 실행합니다. 이 단계에서는 #include 나 #define 등의 구문을 처리하는 단계입니다.<br>
            .i파일로 변환 되고난 후 파일을 열어보면 #include와 같은 내용을 전부 풀어 코드위에 붙여놓은걸 확인할 수 있습니다. 그다음으로는 컴파일러를 실행합니다. 이 단계에서 c와 같은 고수준언어를 저수준언어인 어셈블리언어로 변환해 줍니다.<br>
            이 과정을 거쳐 .i파일은 .s파일로 변환되어 실제로 사용되고 호출되는 부분만 번역되어 작성되기 때문에 줄 수가 .i에 비해 짧습니다. 이러한 이유로 .s 파일은 .i나 .c로 다시 올라갈 수 없습니다. 고수준언어에서 작성했던 부분이 생략되는 부분이 있기에 전단사함수 형태를 띄지 못하기 때문입니다.<br>
            .s파일은 어셈블러를 통해 기계어로 변환되어 .o 파일로 변환됩니다. 이 파일을 hexdump를 이용하면 16진수로 이루어진 코드를 확인할 수 있습니다. 이 .o파일을 링커를 통해 하나로 묶어 .exe 형태로 변환하여 실행할 수 있습니다.</p>
        <h1>nasm과 AT&T</h1>
        <p>C나 Java와 같은 고수준언어와 다르게 어셈블리어는 표준이 없어서 여러 종류의 문법으로 나뉩니다. 그 중 대표적인 문법이 nasm과 AT&T 문법입니다.<br>
            Intel의 nasm 문법은 오퍼랜드1이 목적지, 오퍼랜드2가 소스이지만, AT&T같은 경우 반대로 오퍼랜드1이 소스, 오퍼랜드2가 목적지라는 차이점이 있습니다. 또한, nasm에서는 숫자를 그냥 1,2,3,4 와 같은 형식으로 표기하지만, AT&T는 앞에 $를 붙여 표기하거나, 레지스터 표기도 그냥 rax, rbx 로 쓰는 nasm과 앞에 %를 붙이는 AT&T와 같은 차이점이 있습니다.</p>
        <h1>빅 엔디안과 리틀 엔디안</h1>
        <p>리틀 엔디안과 빅 엔디안은 cpu의 데이터를 저장하는 순서에따라 갈라집니다. 리틀 엔디안은 저장할 때, 하위 바이트를 먼저 저장하고, 빅 엔디안은 상위 바이트를 먼저 저장하는 차이가 있습니다.<br>
            엔디안 방식은 네트워크 통신에서 중요할 수 있습니다. 그 이유로 리틀 엔디안과 빅 엔디안 사이에서 통신하게 될 경우 변환을 해주어야 의도하고자 하는 값을 송수신 할 수 있습니다. 그렇기 때문에 네트워크에서는 빅 엔디안으로 통일되어 있습니다.</p>
        <h1>C인라인 어셈블리</h1>
        <p>C 인라인 어셈블리란, asm파일에서 어셈블리 코딩을 하는 것이 아닌 c파일에서 __asm__ 과같은 구문으로 c에서 어셈블리어 코딩이 가능합니다. 이와같은 방식으로 높은 자유도와 최적화를 수행하는 것이 가능합니다.<br>
            추가적으로 __volatile__ 같은 키워드를 사용하여 컴파일러가 자동으로 최적화하여 원하는 결과가 나오지 않게되는 경우를 방지하는 기능도 사용가능합니다.</p>
        <h1>파일 리버싱</h1>
        <p>리버싱이란 기계어로 번역된 프로그램의 구조와 실제 프로세스로서 작동하는 동작을 파악함으로서, 해당 프로그램의 구조를 파악하는 기술을 의미합니다. 코드가 컴파일 과정을 거쳐 기계어로 되는 과정을 반대로 간다고 할 수 있습니다.<br>
            리버싱 방법에는 두가지가 있습니다. 먼저 파일을 실행하지 않고 파일의 종류, 크기, 헤더정보, 실행 압축 여부 등의 다양한 내용을 확인하고 디스어셈블러를 사용해 그 구졸를 확인하는 등의 행동을로 분석하는 방법인 정적 분석과 파일을 직접 실행시켜 파일, 레지스트리, 네트워크 등을 관찰하고 디버거를 이용해 프로그램 내부 구조와 동작 원리를 분석하는 동적 분석이 있습니다.<br>
            리버싱 과정에서는 주로 실행파일과 헥스(16진수) 코드, 어셈블리 코드를 취급합니다. 그 이유로는 리버싱을 통해 올라갈 수 있는 부분은 어셈블리어 까지이고 그 이상은 일대일 대응이 안되기 때문입니다.<br>
            리버싱은 학습용으로 사용되거나 디버깅, 해킹, 보안과 같은 분야에서 자주 사용되고 있습니다.</p>
    </body>
</html>