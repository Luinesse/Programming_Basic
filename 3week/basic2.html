<html>
    <title>2022 하계방학 프로그래밍기초 3주차 과제</title>
    <head>2020975050 소프트웨어학과 이지홍</head>
    <body>
        <h1>바이너리 코드와 보는 방법</h1>
        <p>바이너리 코드는 말 그대로 이진수로 이루어진 코드를 의미합니다. gcc 컴파일 과정을 통해서 .o파일로 변환되고 나면 그 파일은 컴퓨터가 읽을 수 있는 이진수로 이루어져 있습니다.<br>
            이 파일은 일반적인 방법으로는 vscode에서 읽을 수 없습니다. 그러기에 hexdump와 같은 기능을 이용하여 16진수로 파일을 뜯어볼 수 있습니다.</p>
        <h1>함수 호출 방식 (cdecl, stdcall, fastcall)</h1>
        <h3>cdecl</h3>
        <p>cdecl은 함수 호출용으로 스택에 쌓은 파라미터를 호출한 함수에서 제거해 주는 방식입니다. 함수를 호출할 때, main에서 스택 포인터 연산이 이루어진다는 점이 stdcall과의 차이점입니다.<br>
            이 방식에서 호출 처리 순서로는 호출한 쪽에서 전달할 인자를 스택에 먼저 푸쉬하고, 피호출자인 함수가 실행되고 종료된 후, 호출한 쪽에서 호출한 과정에서 사용된 스택을 정리합니다.</p>
        <h3>stdcall</h3>
        <p>stdcall은 cdecl과는 반대로 피호출자인 함수의 내부에서 스택 포인터 연산을 진행하여 스택을 정리하는 방식입니다. cdecl에서는 호출한 함수에서 스택을 정리하는 코드가 포함되어야 하기에 속도가 조금 더 느렸지만, stdcall에서는 스택 포인터가 정리되는 부분으로 리턴하게 끔 하는 ret 명령어를 사용하여 속도를 빠르게하고 크기도 줄였습니다.<br>
            cdecl에서는 호출한 함수에서 스택을 정리하였기 때문에 가변 인자의 스택 크기를 알 수 있어서 가변 인자를 지원하지만, 호출된 함수에서는 가변 인자의 스택 크기를 알 수 없어서 stdcall에서는 가변 인자를 지원하지 못합니다.</p>
        <h3>fastcall</h3>
        <p>fastcall의 경우 stdcall과 방식은 같으나, 함수에 전달하는 파라미터 최대 2개를 스택이 아닌 레지스터를 이용하여 전달하고 나머지를 스택 메모리를 이용합니다. 스택이 아닌 레지스터에 접근하는 방식 때문에 훨씬 더 빠르다는 장점이 있습니다.</p>
        <h1>치트 엔진과 인증 크랙의 원리</h1>
        <p>치트 엔진은 주로 게임 해킹에서 많이 사용되는 프로그램으로, 오픈 소스로 개발된 메모리 에딧 툴 및 헥스 에디터 프로그램 입니다. 치트 엔진 어셈블러를 통해 코드 인젝션을 손쉽게 할 수 있다는 특징이 있습니다.<br>
            코드 인젝션이란 유효하지 않은 데이터를 실행함으로써 발생하는 소프트웨어 버그의 부당한 사용을 의미하는데, 주로 취약한 컴퓨터 프로그램 코드를 삽입하고 실행을 변경하여 사용합니다.<br>
            이 기능을 통해 스캔한 주소값으로 주소위치로 찾아가 어셈블리 명령어를 수정해 삽입이 가능합니다. 치트 엔진은 이외에도 레지스터 까지의 변경과 디버깅 기능, 1~8 바이트, 다양한 자료형을 스캔할 수 있습니다.<br>
            인증 크랙은 위와 같은 행위로 인증 파일을 수정하여 속여서 인증하는 방식이라고 볼 수 있습니다.</p>
        <h1>CPU 스케줄링과 상태 전이도</h1>
        <p>먼저 CPU 스케줄링이란 작업을 처리하기 위해서 프로세스들에게 CPU를 할당하기 위한 정책을 계획하는 것으로, Ready Queue에 프로세스를 스케줄링 정책에 따라 정렬한 후 앞에 있는 프로세스부터 CPU를 할당합니다.<br>
            스케줄링 방식에는 방법에 따라 크게 두가지, 알고리즘에 따라 크게 여덟가지가 있습니다. 방법에 따라 갈라지는 두가지로는 프로세스 종료 또는 입출력 등의 이벤트가 있을 때까지 실행을 보장해주는 비선점 방식과 OS가 CPU의 사용권을 선점할 수 있는 경우에 강제로 회수하는 선점 방식이 있습니다.<br>
            비선점 방식은 모든 프로세스에게 공정하고 응답 시간이 예측된다는 장점이 있지만, 짧은 작업을 수행하는 프로세스라도 긴 작업이 종료될 때 까지 기다려야 하는 상황이 발생한다는 단점이 있습니다.<br>
            선점 방식은 높은 우선 순위를 가진 프로세스를 빠르게 처리하려는 시스템에 유용하며, 빠른 응답 시간을 요구하는 시분할 시스템을 구현할 때 유용합니다. 하지만 높은 우선 순위를 가진 프로세스들만 들어오게 될 경우 오버헤드가 발생한다는 단점을 가지고 있습니다.<br>
            알고리즘에 따라 갈리는 여덟가지로는 큐에 도착하는 순서대로 CPU를 할당하는 FCFS, FCFS 알고리즘을 보완한 SJF, SJF의 점유 불평등 현상을 보완한 HRN, 수행중인 프로세스의 남은 burst time보다 더 짧은 CPU burst time을 가진 새로운 프로세스가 도착할 경우 CPU를 강제 회수하는 SRTF, 정적/동적으로 우선 순위를 부여하여 우선 순위가 높은 순으로 처리하는 Priority 스케줄링, FSFC에 의해 프로세스를 받아 각 프로세스에 동일한 시간의 시간만큼 CPU를 할당하는 Round Robin<br>
            작업들을 여러 종류의 그룹으로 나누어 여러 개의 큐를 사용하는 다단계 큐, 다단계 큐에서 자신에게 할당된 시간을 다 사용한 프로세스는 밑으로 내리고 시간을 다 채우지 못한 프로세스는 원래 큐 위치 그대로 두는 다단계 피트백 큐가 있습니다.<br>
            이러한 과정은 프로세스의 상태 전이로 이루어집니다. 먼저 프로세스의 상태로는 프로세스가 생성되는 Create, 프로세스가 생성되어 주기억장치에 적재가 되고, 실행하는데 필요한 자원을 모두 얻은 상태인 Ready, 프로세스가 CPU를 점유하여 실행중인 상태인 Running, 프로세스가 종료되는 상태인 Terminated, 주기억장치에 적재는 되었으나 필요한 자원을 얻지 못한 상태인 Asleep, 필요한 자원은 얻었으나 주기억장치에 적재되지 못한 Suspended-Ready 상태, 필요한 자원도, 주기억장치에도 적재되지 못한 상태를 Suspended-Block 상태라고 부릅니다.<br>
            상태 전이로는 프로세스 스케줄러에 의해 결정된 우선순위에 따라 프로세스가 CPU를 점유하는 Dispatch, 프로세스가 실행중에 제한된 시간을 다 소비하여 CPU 점유를 뺏기는 상태인 Time out, 실행중이던 프로세스가 외부 요인에 의해서 자원을 빼앗기는 상태인 Block, 프로세스가 자원을 할당받는 상태인 Wake Up, 프로세스가 주기억장치에 적재되는 상태인 Swap in, 프로세스가 주기억장치에서 해제되는 상태인 Swap Out이 있습니다.<br>
            <img src="https://t1.daumcdn.net/cfile/tistory/233F6A3659310C9A37?original"></p>
        <h1>서버-소켓 구조</h1>
        <p>서버-소켓 구조는 클라이언트 소켓의 연결 요청을 대기하고, 연결 요청이 오면 클라이언트 소켓을 생성하여 통신이 가능하게끔 하는 역할을 합니다. 그 내부에는 socket함수, bind함수, listen함수, accept함수로 이루어져 있습니다.</p>
        <h1>클라이언트-소켓 구조</h1>
        <p>클라이언트-소켓 구조는 실제로 데이터의 송수신이 일어나는 역할을 수행합니다. 서버-소켓 구조와 동일하게 socket함수가 있고, connect함수, send, recv 함수, close 함수가 있습니다.</p>
        <h1>Socket 함수</h1>
        <p>클라이언트 소켓 프로그래밍에서 sockect함수는 소켓 통신을 위해 소켓을 생성하는 함수입니다. 이때, 소켓의 종류를 지정할 수 있는데, TCP 소켓을 위한 스트림 타입, UDP 소켓을 위한 데이터그램 타입 등을 지정할 수 있습니다.<br>
            이 시점에서는 연결 대상에 대한 정보가 없이 소켓만 만들어진 상태이기에 이 소켓을 사용하여 connect 함수를 호출하여야 합니다. 이는 서버 소켓 프로그래밍에서도 동일합니다.</p>
        <h1>connect 함수</h1>
        <p>connect 함수는 클라이언트 소켓 프로그래밍에서 생성된 소켓을 사용하여 IP주소와 포트 번호로 식별되는 대상으로 연결 요청을 보내는 역할을 합니다.<br>
            이 함수는 블록 형태로 동작하여 연결 요청에 대한 결과가 결정되기 전까지는 connect 함수의 실행이 끝나지 않습니다. 이 함수의 호출이 성공하면 데이터 송수신 함수인 send,recv 함수를 통해 데이터를 주고 받는게 가능해집니다.</p>
        <h1>close 함수</h1>
        <p>데이터 송수신이 필요없게 되면, 소켓을 닫기 위해 close 함수를 사용합니다. 이 이후로는 소켓이 닫혀 더이상 유효한 소켓이 아니기 때문에, 해당 소켓으로 데이터를 송수신할 수 없습니다.</p>
        <h1>bind 함수</h1>
        <p>bind 함수는 인자로 소켓과 포트 번호를 받아, 이를 바탕으로 소켓과 포트 번호를 결합하는 작업을 합니다. 이유로는 클라이언트가 서버 소켓에 연결할 때, 모든 소켓이 동일한 포트 번호를 사용한다면 소켓을 결정할 수 없는 문제가 생기기 때문에, 각 서버 소켓에 고정된 포트 번호를 부여하고 일를 결합하여 클라이언트가 포트 번호로 소켓에 연결하게 끔 하기 위함입니다. 이를 주로 소켓 바인드, 소켓 바인딩이라고 부릅니다.</p>
        <h1>listen 함수</h1>
        <p>bind 함수가 끝나고 나면 클라이언트에 의한 연결 요청이 수신될 때 까지 기달리는 listen 함수가 실행됩니다. listen 함수에서 대기 상태를 연결 요청이 올 때까지 지속하는데 이는 요청이 수신되는 경우와 에러가 발생하는 경우에 대기 상태에서 벗어납니다. 이때 리턴값으로는 수신되었는지와 에러가 발생했는지 만을 리턴하는데 그렇기 때문에 클라이언트의 요청값은 가지고 있지 않습니다.<br>
            그 정보는 시스템 내부적으로 관리되는 큐에 저장되고 이 상태를 완전히 연결되지 않은 대기 상태라고 부릅니다. 이 연결 요청을 큐에서 꺼내와서 연결을 완료하기 위해서는 accept 함수를 호출하여야 합니다.</p>
        <h1>accept 함수</h1>
        <p>accept 함수는 listen 함수에서 수신된 경우 실질적인 소켓 연결을 수립하는 함수입니다. 함수에서 데이터 송수신을 위한 새로운 소켓을 만들고 서보 소켓의 대기 큐에 쌓인 첫 번째 연결을 매핑시킵니다. 이때 사용하는 소켓은 앞 단계에서 사용했던 소켓이 아닌 accept 함수 내부에서 생성된 새로운 소켓입니다. 따라서 서버 소켓 프로그래밍에서 close함수는 앞 단계에서 만든 소켓, accept 함수에서 만든 소켓 둘다 close의 대상으로 취급됩니다.</p>
        <h1>파일 디스크립터</h1>
        <p>파일 디스크럽터란 시스템이 특정 파일에 할당해준 정수값을 의미합니다. 네트워크 프로그래밍에서는 소켓 디스크럽터로 소켓 번호, 소켓을 만들고 얻은 파일 디스크립터를 의미합니다. 각 네트워크 함수에서 이 디스크립터를 통해 네트워킹을 수행합니다.</p>
        <h1>HTTP 요청과 응답</h1>
        <p>HTTP 요청과 응답은 TCP/IP 기반으로 HTTP라는 양식을 정해서 데이터 송수신을 하는 과정입니다. HTTP 요청은 Starter Line, Headers, Body로 나뉘고, 응답도 똑같이 세가지로 나뉩니다.<br>
            요청과 응답에서 공통적으로 사용되는 헤더로는 HTTP 메시지가 만들어진 시각을 담는 Date, 현재의 전송이 완료된 후 네트워크 접속을 유지할지 결정하는 Connection, 요청과 응답 메시지의 본문 크기를 바이트 단위로 표시해주는 Content-Length, 불필요한 데이터 요청을 피하고 네트워크를 거치지 않고 캐시에서 응답을 제공하게끔 해주는 Cache-Control, 컨텐츠의 타입과 문자열 인코딩을 명시하는 Content-Type, 사용자의 언어를 표시해주는 Content-Language, 압축된 응답 컨텐츠를 알아서 해제해서 사용하게끔 하는 Content-Encoding이 있습니다.<br>
            공통 헤더를 제외하고 요청헤더에서는 서버의 도메인 네임을 표시하는 Host, 사용자가 어떤 클라이언트를 통해 요청을 보냈는지 표시하는 User-Agent, 클라이언트가 허용할 수 있는 파일 형식을 표시하는 Accept, 클라이언트에 저장된 쿠키를 이름-값 쌍으로 전송하는 Cookie, POST같은 요청을 보낼 때, 요청이 어느 주소에서 시작됐는지를 나타내는 Origin, 페이지가 수정됐을때 최신 버전 페이지 요청을 위한 If-Modified-Since, 인증 토큰을 서버로 보낼 때 사용하는 Authorization이 있습니다.<br>
            응답헤더에서는 웹서버 정보를 나타내는 Server, 리소스에 접근하는 것이 허용된 출처 url을 담는 Access-Control-Allow-Origin, CORS 요청 등을 받는 Allow, 응답 본문을 브라우저가 어떻게 표시해야할지 알려주는 Content-Disposition, 300번대 응답이나 201 Created 응답일 때 어느 페이지로 이동할 지 알려주는 Location, 다른 외부 파일들을 불러올 때, 차단할 소스와 불러올 소스를 명시하는 Content-Security-Policy 헤더가 있습니다.</p>
        <h1>스트레스 테스트</h1>
        <p>스트레스 테스트는 CPU, RAM, DISK의 환경이 갖추어지지 않은 어플리케이션에 비정상적으로 높은 부하를 발생시켜 한계점을 테스트 해보는 것을 의미합니다. 부하를 발생시키면 VM서비스의 다운이나 데이터 소실 등의 시스템 레벨 오작동을 유발시키는 것이 가능해 결점과 결함점을 찾는 것을 목표로 진행하는 경우가 많습니다.<br>
            단 어디까지나 시스템 레벨에서의 결함을 예상하는 수준으로 결과물을 파악할 수 있기에, 실접속자가 발생시키는 부하량과는 매우 다른 케이스를 가질 수도 있습니다.</p>
        <h1>로드 밸런싱</h1>
        <p>로드 밸런싱이란 네트워크 또는 서버에 가해지는 부하를 분산 해주는 기술입니다. 로드 밸런싱은 여러 대의 서버를 두고 서비스를 제공하는 분산 처리 시스템에서 필요한 기술로, 클라이언트의 수가 늘어나서 증가한 트래픽에 대처할 수 없어 서버를 두 대 이상 증설한 경우 여러 대의 서버로 트래픽을 균등하게 분산해주는 역할을 합니다.<br>
            로드 밸런싱 기술은 클라이언트와 서버 혹은 허브 사이에 위치하는 로드 밸런서가 수행합니다. 로드 밸런싱 알고리즘으로는 크게 5가지 종류가 있습니다.<br>
            먼저 서버에 들어온 요청을 순서대로 돌아가며 배정하는 방식인 라운드 로빈방식, 각각의 서버마다 가중치를 매기고 가중치가 높은 서버에 클라이언트 요청을 우선적으로 배분하는 가중 라운드로빈 방식, 클라이언트의 IP주소를 특정 서버로 매핑하여 요청을 처리하는 IP 해시 방식, 요청이 들어온 시점에 가장 적은 연결상태를 보이는 서버에 우선적으로 트래픽을 배분하는 최소 연결 방식, 서버의 현재 연결 상태와 응답시간을 모두 고려하여 트래픽을 배분하는 최소 리스폰타임이 있습니다.</p>
    </body>
</html>