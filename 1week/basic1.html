<html>
    <title>2022 하계방학 프로그래밍기초 1주차 과제</title>
    <head>2020975050 소프트웨어학과 이지홍</head>
    <body>
        <h1>깃명령</h1>
        <h3>add</h3>
        <p>git add 명령어는 사용자가 작업 디렉토리의 내용을 스테이징 영역에 추가하기 위해서 사용하는 깃명령어 중 하나입니다.<br>
            여기서 스테이징 영역이란, 작업 디렉토리와 원격 저장소인 Git 저장소 사이의 임시 저장공간과 같은 영역입니다.<br>
            git add 명령어를 사용할 때에는 스테이징 영역에 올리려는 폴더로 가서 git add . 을 사용하여 add합니다.<br>
            여기서 add 뒤에 .을 붙이면 현재 폴더의 모든 파일은 add한다는 의미입니다.</p>
        <h3>commit</h3>
        <p>git commit 명령어는 git add 명령어를 통해 스테이징 영역에 있는 내용을 로컬 저장소로 업데이트하는 명령어입니다.<br>
            git commit 명령어를 사용할 때에는 -m "커밋 메세지" 형태로 커밋 메세지가 포함되어야 합니다.</p>
        <h3>diff</h3>
        <p>git diff 명령어는 작업 디렉토리와 스테이징 영역, 커밋된 파일과의 비교를 하는 명령어입니다.<br>
            git diff로 실행하면, 스테이징 영역에 올라간 파일과 작업 디렉토리와의 비교를 합니다.<br>
            단, 여기서 add를 하고나서 diff를 하면 수정된 내용이 이미 스테이징 영역에 올라간 상태이므로 아무것도 나오지 않습니다.<br>
            git diff HEAD로 실행하면, commit된 내용과 작업 디렉토리, 스테이징 영역 내용 전부랑 비교합니다.</p>
        <h3>pull</h3>
        <p>git pull 명령어는 원격저장소에 업로드 해놓은 내용을 작업디렉토리로 가져오는 명령어입니다. 이와 유사한 명령어로는 git clone이 있습니다.<br>
            하지만 git clone 명령어는 원격저장소에 업로드된 모든 내용을 가져오는 명령어이고,<br>
            git pull은 작업디렉토리의 내용과 원격저장소의 내용을 비교하여 최신화한 후, 작업디렉토리로 가져옵니다.</p>
        <h3>fetch</h3>
        <p>git fetch 명령어는 로컬저장소에게 원격저장소에서 최신 데이터가 있는지 확인하라는 명령입니다.<br>
            따라서 git pull은 최선 데이터를 복사하여 로컬저장소로 가져오는 반면, git fetch는 변경사항을 확인만 합니다.</p>
        <h3>push</h3>
        <p>git push 명령어는 git commit 명령어를 통해 로컬 저장소에 업데이트된 내용을 원격저장소로 옮기는 명령어입니다.</p>
        <h3>reset</h3>
        <p>git reset 명령어는 사용자가 돌아가고싶은 커밋으로 레파지토리가 재설정되는 명령어입니다.<br>
            git reset (옵션) (돌아가고 싶은 커밋) 과 같은 형태로 사용하며, 옵션에는 크게 3가지가 있습니다.<br>
            첫번째로 hard 옵션은 돌아가려는 커밋으로 돌아가고 그 이후에 있었던 모든 내용은 지워버리는 옵션입니다.<br>
            두번째로 soft 옵션은 돌아가려는 커밋으로 돌아가지만 그 이후 있었던 내용은 스테이징 영역에 올라가 있는 옵션입니다. 이 경우 바로 커밋할 수 있습니다.<br>
            마지막으로 mixed 옵션은 똑같이 돌아가려는 커밋으로 돌아가지만 그 이후 있었던 내용이 남아있긴 하지만, 스테이징 영역에 올라가 있지 않는 상태로 돌아갑니다.<br>
            돌아가고 싶은 커밋은 해시형태로 입력을 줄 수 도있고, 몇개의 커밋으로 되돌리는 형태로도 사용이 가능합니다. ex) git reset --hard (해시값), git reset HEAD~6</p>
        <h3>restore</h3>
        <p>git restore 명령어는 작업 디렉토리 내에서 변경사항들을 취소하는 명령어입니다. 이 명령어도 reset명령어와 같이 몇개의 커밋의 파일로 복구시키는 옵션이 존재합니다.<br>
            이 명령어를 수행하면 작업 디렉토리 내에서 파일 단위로 수정된 내용들을 취소하기 때문에 수백개의 파일을 수정한걸 돌리고 싶을때 편리하게 사용할 수 있습니다.</p>
        <h3>status</h3>
        <p>git status 명령어는 현재 파일의 상태를 확인할 수 있습니다. 어떤 파일을 수정하고 나서 git status 명령어를 수행하면, 수정된 파일은 Untracked file로 분류됩니다.<br>
            그럼 후에 add명령어를 통해 Tracked 상태로 변환 후 깃은 Tracked 상태의 파일만 커밋합니다.</p>
        <h3>log</h3>
        <p>git log 명령어는 커밋 기록을 조회하는 명령어 입니다. git log 명령어의 옵션으로는 -p와 -숫자 옵션이 있습니다.<br>
            -p는 각 커밋들의 diff결과를 출력해주고, -숫자 옵션은 최근 몇개의 내역을 보여줄 것인지를 설정하는 옵션입니다.</p>
        <h1>CLI</h1>
        <p>CLI는 Command-Line Inteface의 약자로 가상 터미널이나 터미널을 통해서 사용자와 컴퓨터가 상호작용하는 방식을 말합니다. 명령은 사용자가 키보드와 같은 입력장치를 통해 문자열로 입력하며, 출력 역시 문자열 형태로 주어집니다.<br>
            과거 GUI가 사용되기 이전 MS-DOS와 같은 OS에서 CLI가 사용되었으며, 현재는 명령 프롬포트나, 컴퓨터 프로그래밍 등에서 여전히 사용중입니다.</p>
        <h1>GUI</h1>
        <p>GUI는 CLI에서처럼 사용자가 명령어를 입력해서 실행결과를 이해하는데 어려움을 겪었던 것에 비해, 그래픽으로 다 구현해서 보여주는 방식이므로 프로그래밍 언어를 몰라도 조작이 편리합니다.<br>
            Windows, Linux 등 대부분의 OS, 모바일 운영체제에서 GUI를 지원하고있습니다.</p>
        <h1>게임물리와 그래픽스</h1>
        <h3>게임물리</h3>
        <p>게임물리는 게임에서 사용되는 물리 현상들을 의미합니다. 대표적으로 게임엔진인 유니티엔진과 언리얼엔진에서 물리엔진을 통해 물리현상을 처리합니다.<br>
            특히 VR게임이나 3D게임에서는 물리법칙이 적용되지 않으면 현실과 괴리감이 클 수 있으므로 중요하게 다루어져야합니다.<br>
            3D엔진을 사용하지 않는 환경인 2D게임에서도 프로그래머가 코딩을 통해 중력이나 관성과 같은 물리적 현상을 처리해주어야 현실성 있는 게임을 구현할 수 있습니다.<br>
            게임 물리에는 각종 역학과 중력, 마찰력, 인력 등 물리적 효과들이 포함되며, 게임의 형태에 따라 인위적으로 현실에 없는 물리효과를 추가하여 구현하는 경우도 있습니다.</p>
        <h3>그래픽스</h3>
        <p>게임에서 필수적인 요소로 컴퓨터 그래픽으로 표현될 이미지가 있습니다. 게임은 결국 여러개의 프레임이 합쳐져서 움직인다고 볼 수 있습니다.<br>
            여기서, 디자이너는 개발하려는 게임의 프레임 수 에 맞추어서 이미지 스프라이트를 만들어주어야합니다.<br>
            그리고 생성된 요소들은 게임 진행 중 어떤 다른 요소와 충돌할 수 있기 때문에, 자연스러운 충돌을 구현하기 위해 디자이너는 가급적 요소의 크기에 맞는사이즈로 디자인 하여야하고 뒷 배경을 날려주는 작업을 해주어야합니다.<br>
            코딩을 하는 사람은 이미지 스프라이트에 맞춰서 적절한 충돌함수를 작성 해주는 것이 필요합니다. 또한 이미지들의 이동속도를 각각 다르게하여 현실적으로 표현하는 것도 중요하다고 생각합니다.<br>
            추가적으로, 게임을 바라보는 카메라의 위치를 다르게하여 2D에서도 쿼터뷰, 탑뷰 등으로 시각적으로 다르게 구현하는것도 필요합니다.</p>
        <h1>WOL</h1>
        <p>WOL은 Wake on Lan의 약자로 컴퓨터가 특정 네트워크 메세지를 받으면 컴퓨터 전원을 키게 되는것인데, 먼저 BIOS에서 컴퓨터 파워 옵션세팅을 해두어야만 사용가능합니다.<br>
            Wake on Lan의 원리로는 네트워크 연결에서 주고받는 데이터인 패킷을 WOL기능을 할 수 있도록 특별히 디자인 하여, 매직 패킷으로 디자인하고 LAN카드는 이 패킷을 받게되면 전원을 켜게되는 원리입니다.<br>
            단 유선에서만 가능한 원리이므로 무선에서는 WoWLAN 방식을 사용하여야 합니다. 하지만, 설정이 힘들고 지원하는 LAN카드 또한 적습니다.</p>
        <h1>AC부팅</h1>
        <p>AC 부팅또한, 위에서 서술한 WOL과 같이 BIOS에서 컴퓨터 파워 옵션세팅을 끝내고 나면 원격으로 컴퓨터의 전원을 켜고 끄는것이 가능합니다.</p>
        <h1>스레드</h1>
        <p>스레드란, 독립적으로 실행될 수 있는 최소 크기의 프로그램 단위입니다. 모든 프로세스는 한 개 이상의 스레드를 가지며, 이러한 스레드를 두 개 이상 가지는 프로세스를 멀티 스레드 프로세스라고 합니다.<br>
            이러한 방식의 장점으로는 CPU의 사용률이 올라가는 효과와 응답성 향상, 효율적인 자원사용 등이 있습니다. 하지만 같은 프로세스 내에서 여러 스레드가 자원을 공유하므로, 데이터의 동기화나 교착상태가 발생할 수 있으니 고려하여 프로그래밍 해야합니다.<br>
            여기서 데이터 동기화 문제란, 여러 스레드가 한 프로세스안에서 작업중인 내용이 공유될 수 있으므로 발생하는 문제입니다. 이때, 한 스레드가 진행 중인 작업을 다른 스레드가 간섭하지 못하도록 하는 것이 스레드의 동기화 입니다.<br>
            교착상태는 둘 이상의 스레드가 서로의 작업이 끝나길 기다리며 작업을 진행하지 못하는 상태를 의미합니다. 여기서 교착상태에 빠지기 위해서는 4가지 조건이 모두 충족 되어야합니다.<br>
            먼저 한 스레드가 접근하는 자원은 다른 스레드가 접근하지 못하도록 하는 상호배제가 있습니다. 두번째로는 한 스레드가 사용중인 자원은 중간에 다른 스레드가 빼앗지 못하는 비선점입니다.<br>
            세번째로는, 스레드가 다른 스레드가 필요로하는 자원을 점유하면서 또 다른 자원을 기다리는 상태인 점유와 대기가 있습니다. 마지막으로 점유와 대기를 하는 스레드간의 관계가 원을 이루는 원형 대기가 있습니다.<br>
            위 4개가 모두 충족할때 교착상태가 발생하며, 해결을 위해 예방,회피,검출을 통해 교착상태를 해결합니다.</p>
        <h1>문맥교환</h1>
        <p>문맥교환이란, 하나의 프로세스가 CPU를 사용중인 상태에서 다른 프로세스가 CPU를 사용할 수 있도록 하기 위해, 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 상태를 적재하는 작업을 말합니다.<br>
            대표적으로 멀티 태스킹 환경에서 운영체제가 프로세스에 CPU자원을 할당할때 일어납니다. 각 프로세스는 CPU를 점유하는 시간이 있고, 그 시간이 끝나게되면 다음 프로세스에게 CPU를 넘겨 주어야하기 때문에 자신의 문맥을 저장해두고 다음 프로세스는 이전에 저장했던 자신의 문맥을 가져와 복원 시켜 수행합니다.<br>
            여기서 문맥교환이 일어나는 동안 시간과 메모리가 소요되는데, 이를 오버헤드라고 부릅니다. 문맥교환이 아닌 경우도 있습니다.<br>
            대표적으로 일반적인 인터럽트나 시스템 콜이 들어오면 현재 프로세스의 문맥 일부를 저장하고 운영체제 커널의 코드가 실행되지만 CPU점유시간이 끝나서 인터럽트가 걸리는 상황이나, I/O 요청으로 인한 시스템 콜로 인해 커널모드로 전환된 것이 아니므로 문맥교환이 아닙니다.</p>
        <h1>데이터 경쟁상태</h1>
        <p>데이터의 경쟁상태란, 여러개의 프로세스가 공유 자원에 동시에 접근하게 되면 실행 순서에 따라 결과값이 달라질 수 있는 현상을 의미합니다.<br>
            경쟁상태는 커널모드에서 데이터를 로드하여 작업하던 도중 인터럽트가 발생하여 같은 데이터를 조작하는 경우나, 시스템 콜로인해 커널모드에서 작업을 수행하는 도중 문맥 교환이 발생하면 경쟁상태가 발생할 수 있습니다.<br>
            이를 해결하기 위해서는 먼저 각 프로세스에서 공유자원에 접근하는 프로그램 코드 부분인 임계 영역 상의 문제를 해결해 주어야합니다. 임계 영역 문제를 해결하기 위해서는 다음 세 가지 조건을 충족하여야 합니다.<br>
            먼저, 한 프로세스가 자신의 임계 영역에서 작업 중이면 다른 프로세스들은 임계영역에 진입할 수 없도록 하는 상호 배제가 있습니다.<br>
            두번째로는 아무도 임계 영역에 있지않다면, 진입하고자 하는 프로세스를 진입하게 해주는 진행이 있습니다.<br>
            마지막으로, 프로세스가 임계 영역에 진입하기 위해 무한정 기다리는 현상이 발생하면 안되는 유한대기가 있습니다. 이 세 가지가 모두 충족되면 임계 영역 문제를 해결할 수 있다고 볼 수 있습니다.</p>
        <h1>REST-API</h1>
        <p>REST-API란 REST를 기반으로 만들어진 API를 말합니다. 여기서 REST란, Representational State Transfer의 약자로 자원을 이름으로 구분하여 해당 자원의 상태를 주고 받는 모든것을 의미합니다.<br>
            그러므로 REST는 자원과, 자원에 대한 행위, 자원에 대한 행위의 내용으로 이루어져 있습니다. REST의 특징으로는 서버-클라이언트 구조로 이루어져 있으며, 상태가없고, 캐시처리가 가능하고, 계층화되어있으며, 인터페이스가 일관적이라는 특징이 있습니다.<br>
            장점으로는 HTTP 프로토콜의 인프라를 그대로 사용하므로 따로 인프라의 구축이 필요없으며, 범용성을 보장하고,REST API 메세지가 의도하는 바를 쉽게 파악할 수 있으며, 문제 최소화 및 서버와 클라이언트의 역할을 명확하게 분리해주는 장점이 있습니다.<br>
            반면, 단점으로는 표준 자체가 존재하기 않아 정의가 필요하며, HTTP Method 형태가 제한적이고, 구형 브라우저에서 호환이 되지않는 부분이 있습니다.</p>
        <h1>CI/CD</h1>
        <h3>CI</h3>
        <p>CI는 Continuous Integration의 약자로 여러명이 하나의 코드에 대해서 수정을 진행해도 지속적으로 통합하면서 관리할 수 있음을 뜻합니다.<br>
            CI가 없었을 때에는 개발을 마치고 배포 후에야 코드에 오류가 있는지 없는지를 검증하고 관리가 가능했으나, 이후에는 각자의 개발자가 자신이 구현해야할 기능을 구현하고 main과 통합 후 테스트가 가능해졌습니다.<br>
            요약하자면 개발자가 구현한 코드를 기존 코드와 병합하고 병합된 코드가 올바르게 동작하는지 검증합니다. 그리고 문제가 있다면 다시 처음으로 돌아가고, 문제가 없다면 배포를 진행합니다.</p>
        <h3>CD</h3>
        <p>CD는 지속적 배포라는 의미로, CI를 통해 빌드된 코드를 테스트가능한 알파나 베타버전으로 만들고, 이 버전에서 테스트를 수행하여 문제가 발생하면 수정한 뒤 정식버전으로 배포를 진행합니다.<br>
            따라서 CD를 사용하면 소프트웨어가 항상 신뢰가능한 수준에서 배포될 수 있도록 관리가 가능해집니다.</p>
    </body>
</html>