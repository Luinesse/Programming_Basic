<html>
    <title>2022 하계방학 프로그래밍기초 2주차 과제</title>
    <head>2020975050 소프트웨어학과 이지홍</head>
    <body>
        <h1>On-premise와 Off-premise</h1>
        <h3>On-premise</h3>
        <p>On-premise는 기업의 서버를 클라우드와 같은 원격 환경에서 운영하는 방식이 아닌, 자체적으로 보유한 전산실 서버에 직접 설치하여 운영하는 방식을 의미합니다.<br>
            온프레미스와 오프 프레미스를 설명하기에 앞서 클라우드 컴퓨팅이란, 네트워크(클라우드)를 통해 물리적 자원, 소프트웨어를 제공받는 것을 의미합니다.<br>
            온프레미스는 클라우딩 컴퓨팅 기술이 나오기 이전에는 기업의 비지니스 정보를 보안성 높게 관리할 수 있다는 장점때문에 기업 인프라 구축의 일반적인 방식이었으나, 시스템을 구축하는데 있어서 많은 시간과 비용이 들어간다는 단점이 있었습니다.<br>
            따라서, 현재 클라우딩 컴퓨팅 기술을 이용해 보안성이 높은 데이터는 온프레미스 환경에서 사용하고, 보안성이 낮은 데이터는 클라우드 환경에서 사용하는 하이브리드 방식의 인프라가 등장했습니다.</p>
        <h3>Off-premise</h3>
        <p>Off-premise는 On-premise의 반대의 서비스로 클라우드 방식의 인프라 구축을 의미합니다. 자체 전산실 서버에 직접 설치해야하는 온프레미스에 비해 오프 프레미스는 클라우드 방식을 사용하여 구축이 쉽고 간편하다는 장점이 있습니다.<br>
            오프 프레미스 방식은 네트워크를 통해 운영을 제공받는데, 서비스들은 제공범위에 따라 IaaS, PaaS, SaaS로 나눌 수 있습니다.</p>
        <h1>IDC</h1>
        <p>IDC는 인터넷 데이터 센터의 약자로, 인터넷 연결의 핵심이 되는 서버를 한 데 모아 집중시킬 필요가 있을 때 설립하는 시설을 의미합니다. 클라우드 컴퓨팅을 위한 데이터 센터또한 IDC에 포함되는데, 이는 일반적인 데이터 센터들도 클라우드 컴퓨팅 기능을 모두 포함하고 있기 때문입니다.<br>
            IDC는 서버들을 한데 모아 안정적으로 운용해주는 시설인데, 이곳의 서버가 멈추면 안되기 때문에, 정전되지 않게 설계하거나 전력을 우선적으로 공급받기도 합니다.</p>
        <h1>IaaS</h1>
        <p>IaaS는 Infrastructure as a service의 약자로, 가상화된 서버를 구현하기 위한 시스템과 물리적 자원을 제공한다는 의미입니다. IaaS는 서버 운영이 쉽고 편리하여 효용성이 높기 때문에 각광받고 있습니다.<br>
            대표적인 서비스 제공 프로그램으로는, AWS, Microsoft Azure, GCP, Alibaba Cloud 등이 IaaS를 제공합니다.</p>
        <h1>PaaS</h1>
        <p>PaaS는 IaaS에서 제공된 서버에 더해 개발까지 할 수 있는 플랫폼을 구축하여 이를 서비스 형태로 제공하는 것입니다. PaaS는 운영체제, 미들웨어, 런타임 등이 이미 구축된 상태로 제공하기 때문에 IaaS에 비해 관리상의 자유도가 낮고, PaaS 플랫폼에 종속될 여지가 있습니다.<br>
            하지만 PaaS 사용자는 서비스 외적인 부분에 신경 쓸 필요가 없고, 개발과 비즈니스에 집중할 수 있게 해주고, 인프라의 유지,운영에 인력이 들지 않기 때문에 비용절감에 있어서 장점이 있습니다.<br>
            대표적인 서비스 제공 프로그램으로는 세일즈포스 닷컴의 Heroku나 레드햇의 OpenShift 등이 PaaS를 제공합니다.</p>
        <h1>SaaS</h1>
        <p>SaaS는 IaaS와 PaaS를 통틀어 가장 완성된 형태의 클라우드 서비스 입니다. 클라우드 인프라 위에 소프트웨어를 탑재하여 제공하는 형태로 IT 인프라 자원뿐만 아니라 소프트웨어 및 업데이트, 버그 개선 등의 서비스를 업체가 도맡아 처리합니다.<br>
            SaaS를 이용하게 될 경우 자체적으로 소프트웨어를 개발하는 것에 대비해 초기 비용을 대폭 줄일 수 있다는 장점이 있습니다. 하지만, 인터넷 연결 상태에 따라 성능이 달라질 수 있고, 업체가 제공하는 기능을 그대로 사용해야 하기 때문에 불필요한 기능이 포함되어 있을 수 있습니다.<br>
            현대에 들어 비즈니스를 함에 있어 IT 인프라는 필수가 될 정도로 비용절감, 확장, 축소의 유연성, 사용한 만큼의 비용 지불 등의 이유로 비즈니스에 집중할 수 있게 해주어 많이 사용합니다.<br>
            대표적인 서비스 제공 프로그램으로는 마이크로소프트의 Office 365, 드롭박스, 세일즈포스 등이 SaaS를 제공합니다.</p>
        <h1>rm-rf와 위험성</h1>
        <p>리눅스 명령어중 하나인 rm(remove) 명령어는 파일을 삭제하는 명령어입니다. 뒤의 -rf는 옵션인데, r의 경우는 recursive로 폴더를 삭제하기 위해서 재귀적 삭제를 실행하도록 하는 옵션이고, f는 force로 액세스 권한이 없는 파일도 강제로 삭제하는 옵션입니다.<br>
            폴더내의 모든 파일을 없애준다는 점에서 편리함도 있지만, 관리자 권한으로 접속하여 sudo rm-rf /*와 같은 오타를 내버리면 최상위 폴더에서 모든 내용을 삭제해버리기 때문에 각별한 주의가 필요합니다.<br>
            따라서, rm-rf 명령어를 수행할 때에는 root권한에서는 실행하지 않는것이 권장됩니다. WSL환경에서 실행하는 경우 윈도우 까지 삭제될 수 있으므로 재차 확인하여야 합니다.</p>
        <h1>grep</h1>
        <p>리눅스 명령어 중 하나인 grep 명령어는 특정 파일에서 지정한 문자열이나 정규표현식을 포함한 행을 출력해주는 명령어 입니다. grep 명령어는 grep [옵션][찾고자 하는 것][파일명] 으로 사용합니다.<br>
            옵션은 먼저 일치하는 행의 수를 출력해주는 -c 옵션, 대소문자를 구별하지 않는 -i 옵션, 일치하지 않는 행만 출력하는 -v 옵션, 포함된 행의 번호를 함께 출력하는 -n 옵션, 패턴이 포함된 파일의 이름을 출력하는 -l 옵션, 단어와 일치하는 행만 출력하는 -w 옵션,<br>
            라인과 일치하는 행만 출력하는 -x 옵션, 하위 디렉토리를 포함한 모든 파일에서 검색하는 -r 옵션, 최대로 표시될 수 있는 결과를 제한하는 -m 숫자 옵션, 찾을 패턴을 정규 표현식으로 찾는 -E 옵션, 찾을 패턴을 문자열로 찾는 -F 옵션이 있습니다.<br>
            grep은 grep과 egrep, fgrep으로 3종류로 나뉘어집니다. egrep은 grep에서 -E옵션을 사용하는 것과 같습니다. fgrep 또한 grep에서 -F 옵션을 쓰는것과 같습니다.</p>
        <h1>파일 사용자와 그룹</h1>
        <p>각 파일은 읽거나 쓰거나 실행할 권리를 사용자, 그룹, 다른 사용자로 나누어서 관리를 합니다. 그중 파일 사용자로 통용되는 user는 파일을 만든 소유주를 의미합니다.<br>
            그룹은 파일을 만든 소유자가 속한 그룹의 다른 사용자들을 의미합니다. 그리고 그 외는 다른 사용자인 other로 구분합니다.</p>
        <h1>netstat</h1>
        <p>netstat 명령은 네트워크 접속, 라우팅 테이블, 네트워크 인터페이스의 통계 정보를 보여주는 도구입니다. 사용방법은 netstat [옵션][| grep 포트번호 or 서비스 명] 형식으로 사용합니다.<br>
            옵션은 먼저 연결 가능한 상태를 보여주는 -l 옵션과 포트넘버를 보여주는 -n 옵션, tcp 정보를 보여주는 -t 옵션, udp 정보를 보여주는 -u 옵션, 프로그램 이름과 PID를 보여주는 -p 옵션<br>
            그리고 모든 정보를 보여주는 -a 옵션, 이더넷 카드별 정상/에러/드랍 송수신 패킷 수를 확인하는 -i 옵션, 라우팅 테이블 정보를 보여주는 -r 옵션, 네트워크 통계를 보여주는 -s 옵션이 있습니다.<br>
            위 옵션들을 적절히 이용하여 netstat 명령을 사용할 수 있는데 자주 사용하는 옵션으로는 현재 사용중인 모든 ip와 tcp, udp포트, 상태여부, 사용하는 프로세스를 모두 출력하는 -npa 옵션과 같은 옵션이 있습니다.</p>
        <h1>UFW</h1>
        <p>리눅스의 방화벽 중 가장 많이 사용되는 방화벽인 iptables의 작업을 간편화 해주는 소프트웨어를 UFW라고 부릅니다. ufw enable 명령을 통해 방화벽을 활성화 할 수 있고, allow, deny 옵션을 통해 특정 포트를 허용 혹은 거부할 수 있습니다.<br>
            UFW의 뜻과 같이 복잡하지 않은 방화벽이므로 iptables보다 직관적이고 사용이 쉽지만, 수준 높은 방화벽의 구성에는 iptables 룰을 직접 사용해야 한다고 합니다.</p>
        <h1>service</h1>
        <p>리눅스에서 서비스란 시스템이 부팅될 때 백그라운드에서 자동 실행되는 응용프로그램들 중에서 사용자에게 어떠한 서비스들을 제공하기 위한 데몬들을 리눅스 서비스라고 부릅니다. 여기서 데몬이란 일반적으로 시스템이 켜질 때 부터 꺼질 때까지 지속적으로 작동하는 프로세스를 말합니다.<br>
            리눅스 서비스와 관련된 설정을 세팅하거나 확인하기 위해 systemctl 명령어를 사용합니다.</p>
        <h1>branch</h1>
        <p>깃허브에서 branch란 독립적으로 어떤 작업을 진행하기 위한 개념으로 트리 방식으로 버전을 분산하여 관리할 수 있습니다. 메인 브랜치에서 자신의 작업을 위한 브랜치를 만들어서 작업하므로, 메인 브랜치에 영향을 주지 않은채 각자의 작업을 진행할 수 있습니다.<br>
            이후 병합작업을 함으로써, 나누어서 작업했던 브랜치를 메인 브랜치로 모을 수 있습니다. git branch "브랜치 이름" 명령으로 새로운 브랜치를 만들 수 있습니다. 이후 git checkout "브랜치 이름" 으로 작업 브랜치를 변경하면서 작업을 수행할 수 있습니다.<br>
            작업 이후, 푸쉬를 하려면 git push 명령에 --set -upstream origin "브랜치 이름" 으로 옵션을 붙여주면 브랜치 정보를 원격 저장소에 업로드합니다. 로컬 저장소에 올라간 브랜치를 지우려면 git branch -D "지울 브랜치 이름" 을 하면 됩니다.<br>
            원격 저장소의 브랜치를 지울려면 git push origin -d "지울 브랜치 이름" 명령으로 지울 수 있습니다. 브랜치를 포함한 로그를 볼려면 git log --branches --decorate --graph로 볼 수 있습니다. 여기에 --oneline 옵션을 더 붙여주면 한 칸 단위로 로그를 볼 수 있습니다.</p>
        <h1>stash</h1>
        <p>깃허브에서 stash 명령어는 자신이 어떤 작업을 하던 도중 다른 요청이 들어와 작업을 멈추고 다른 브랜치에서 작업해야할 때, commit하기에 껄끄러운 상황에 하던 작업을 임시로 저장할 수 있는 명령어입니다.<br>
            stash 명령어로 저장하지 않고 다른 브랜치로 넘어가게되면 작업하고 있던 내용이 다른 작업브랜치의 위로 붙어서 넘어오기 때문에 데이터 독립성 문제가 생깁니다. 따라서, git stash를 통해 스택에 임시 저장을 해주어야합니다.<br>
            스택에 저장된 현황을 보려면 git stash list 명령을 수행하면 됩니다. git stash apply 명령을 수행하면 스택에서 세이브된 작업 내용을 로드합니다. 이때, 스택방식을 사용하기 때문에 위에있는 내용부터 로드됩니다.<br>
            git stash drop은 세이브된 작업 내용을 지우는 명령어이고, git stash pop은 세이브된 작업 내용을 가져옴과 동시에 세이브 파일을 스택에서 삭제합니다.</p>
        <h1>merge</h1>
        <p>깃허브에서 merge 명령어는 앞에서 설명한 branch 명령어를 통해 분산된 브랜치들을 다시 병합하는 작업입니다. git merge [브랜치 명] 을 통해 수행하면 되는데, 이때 브랜치는 흡수를 당하는 브랜치가 아닌 흡수를 하는 브랜치에서 수행하여야 합니다.<br>
            왜냐하면 merge는 현재 브랜치에서 수행하기 때문입니다. merge 명령어를 통해 흡수된 브랜치가 공통된 부분이 있을 시 후술할 merge conflict 문제가 생길 수 있습니다. Git에서 merge는 3-way Merge 방식을 사용합니다.<br>
            3-way Merge는 기본 값과 사용자의 커밋, 다른 사용자의 커밋으로 구분하여 병합하여 기본 값에서 변경된 커밋을 기준으로 병합을 하는 방식입니다. 여기서 사용자의 커밋, 다른 사용자의 커밋이 기본 값과 비교했을 때 둘다 변경 됐을때 merge conflict가 발생합니다.</p>
        <h1>conflict</h1>
        <p>conflict 문제는 위에서 설명했듯이, merge 명령어를 실행했을 때, 3-way merge 방식을 거쳐 충돌 문제가 발생했을 때 확인할 수 있습니다. 주로 두 브랜치간의 충돌이나 두 커밋간의 충돌로 인해 발생합니다.<br>
            브랜치 간의 충돌은 로컬 저장소에서 일어나고, 커밋간의 충돌은 원격저장소로 풀/푸시를 하는 과정에서 발생합니다. 이때, 병합 충돌이 발생하면 위쪽에 흡수를 하는 브랜치(커밋)의 코드, 아래쪽에 흡수를 당하는 브랜치(커밋)의 코드가 출력되고 사용자가 의도한 코드가 나오게끔 수정하여 커밋 혹은 푸시를 진행하여야 합니다.<br>
            흡수를 하는 브랜치의 코드로 정하고 가는 방법과 흡수를 당하는 브랜치의 코드로 정하고 가는 방법, 둘다 비교해서 사용자가 섞거나 혹은 수정하는 방법이 있습니다. 하지만 3-way Merge에서 충돌은 실제 개발 상황에서 작업자들 간 조율이 제대로 안됐을때 나타나므로 빈도가 높지는 않습니다.</p>
        <h1>ps와 kill</h1>
        <p>리눅스에서 ps 명령어는 현재 돌아가고 있는 프로세스를 확인할 수 있는 명령어 입니다. 사용할 때에는 ps [옵션] 으로 사용합니다. 옵션으로는 모든 프로세스를 출력하는 -A 옵션, 터미널과 연관된 프로세스를 출력하는 a 옵션, 세션 리더를 제외하고 터미널에 종속되지 않은 모든 프로세스를 출력하는 -a 옵션<br>
            그리고, 커널 프로세스를 제외한 모든 프로세스를 출력하는 -e 옵션, 유닉스 스타일로 출력해주는 옵션인 -f 등이 있습니다.<br>
            이 명령어로 프로세스의 PID를 확인 후 프로세스를 종료시키는 명령어인 kill을 사용합니다. kill은 kill - 9 PID 를 통해 프로세스를 종료합니다. 이 명령어를 위해 ps 명령어로 PID를 확인합니다.</p>
    </body>
</html>